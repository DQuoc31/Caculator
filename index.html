<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Máy tính Windows 11 - Chuẩn</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="Caculator.css">
</head>
<body>
    <div class="calculator-container">
        <div class="calculator">
            <div class="title-bar">
                <button class="menu-btn">
                    <i class="fas fa-bars"></i>
                </button>
                <div class="calculator-type">Chuẩn</div>
                <button class="history-toggle" id="historyToggle">
                    <i class="fas fa-history"></i>
                </button>
            </div>
            
            <div class="display">
                <div class="previous-operand"></div>
                <div class="current-operand">0</div>
            </div>
            
            <div class="buttons-grid">
                <!-- Hàng 1 -->
                <button class="btn btn-clear math-func" data-action="percent">%</button>
                <button class="btn btn-clear" data-action="clear-entry">CE</button>
                <button class="btn btn-clear" data-action="clear-all">C</button>
                <button class="btn btn-clear" data-action="backspace">
                    <i class="fas fa-backspace"></i>
                </button>
                
                <!-- Hàng 2 -->
                <button class="btn btn-operation math-func" data-operation="sqrt">√<span style="text-decoration: overline">x</span></button>
                <button class="btn btn-operation math-func" data-operation="square">x²</button>
                <button class="btn btn-operation math-func" data-operation="reciprocal">¹⁄<span style="text-decoration: overline">x</span></button>
                <button class="btn btn-operation" data-operation="÷">÷</button>
                
                <!-- Hàng 3 -->
                <button class="btn btn-number" data-number="7">7</button>
                <button class="btn btn-number" data-number="8">8</button>
                <button class="btn btn-number" data-number="9">9</button>
                <button class="btn btn-operation" data-operation="×">×</button>
                
                <!-- Hàng 4 -->
                <button class="btn btn-number" data-number="4">4</button>
                <button class="btn btn-number" data-number="5">5</button>
                <button class="btn btn-number" data-number="6">6</button>
                <button class="btn btn-operation" data-operation="-">–</button>
                
                <!-- Hàng 5 -->
                <button class="btn btn-number" data-number="1">1</button>
                <button class="btn btn-number" data-number="2">2</button>
                <button class="btn btn-number" data-number="3">3</button>
                <button class="btn btn-operation" data-operation="+">+</button>
                
                <!-- Hàng 6 -->
                <button class="btn btn-number math-func" data-action="toggle-sign">±</button>
                <button class="btn btn-number" data-number="0">0</button>
                <button class="btn btn-number" data-number=".">.</button>
                <button class="btn btn-equals" data-action="calculate">=</button>
            </div>
        </div>
        
        <div class="history-panel" id="historyPanel">
            <div class="history-header">
                <span>Lịch sử</span>
                <button class="clear-history" id="clearHistory">Xóa lịch sử</button>
            </div>
            <div class="history-content" id="historyContent">
                <div class="no-history">Chưa có phép tính nào</div>
            </div>
        </div>
    </div>

    <script>
        class Calculator {
            constructor() {
                this.previousOperandElement = document.querySelector('.previous-operand');
                this.currentOperandElement = document.querySelector('.current-operand');
                this.historyContent = document.getElementById('historyContent');
                this.history = JSON.parse(localStorage.getItem('calculatorHistory')) || [];
                this.clear();
                this.justCalculated = false; // flag to detect recent calculation
                this.lastExpression = '';
                this.loadedFromHistory = false;
                this.showLastExpression = false;
                this.updateDisplay();
                this.renderHistory();
            }

            clear() {
                this.currentOperand = '0';
                this.previousOperand = '';
                this.operation = undefined;
                this.waitingForNewOperand = false;
                this.justCalculated = false;
                this.lastExpression = '';
                this.loadedFromHistory = false;
                this.showLastExpression = false;
            }

            clearEntry() {
                this.currentOperand = '0';
                this.justCalculated = false;
            }

            delete() {
                // If a history item has been loaded into the display, disable backspace until user types or changes state
                if (this.loadedFromHistory) {
                    return;
                }
                // If the last action was a completed calculation, backspace should remove that calculation from history
                if (this.justCalculated) {
                    // clear the result and previous expression
                    this.currentOperand = '0';
                    this.lastExpression = '';
                    this.showLastExpression = false;
                    this.justCalculated = false;
                    return;
                }

                if (this.currentOperand.length === 1) {
                    this.currentOperand = '0';
                } else {
                    this.currentOperand = this.currentOperand.slice(0, -1);
                }
            }

            appendNumber(number = '') {
                // If user just loaded a history item, start a new current operand but keep previousOperand and operation
                if (this.loadedFromHistory) {
                    this.currentOperand = number;
                    this.loadedFromHistory = false;
                    // do not show the saved full expression once user starts typing after operator
                    this.showLastExpression = false;
                    this.waitingForNewOperand = false;
                    this.updateDisplay();
                    return;
                }
                // Nếu nhập số sau khi vừa tính toán xong, tạo phép tính mới
                if (this.justCalculated) {
                    // clear previous expression when starting a fresh input
                    this.previousOperand = '';
                    this.lastExpression = '';
                    this.currentOperand = number;
                    this.justCalculated = false;
                    this.waitingForNewOperand = false;
                    return;
                }

                if (this.showLastExpression && this.previousOperand !== '' && this.operation != null) {
                    // clear preview
                    this.lastExpression = '';
                    this.showLastExpression = false;
                    this.loadedFromHistory = false;
                    this.justCalculated = false;
                    // start new current operand based on input (handle decimal)
                    if (number === '.') {
                        this.currentOperand = '0.';
                    } else {
                        this.currentOperand = number;
                    }
                    this.waitingForNewOperand = false;
                    return;
                }

                if (this.waitingForNewOperand) {
                    this.currentOperand = number;
                    this.waitingForNewOperand = false;
                } else {
                    if (number === '.' && this.currentOperand.includes('.')) return;
                    if (this.currentOperand === '0' && number !== '.') {
                        this.currentOperand = number;
                    } else {
                        this.currentOperand += number;
                    }
                }
            }

            chooseOperation(operation) {
                // If there is no current input, ignore
                if (this.currentOperand === '') return;

                // Prevent choosing an operator when currentOperand is a non-numeric warning/error message
                const curClean = (this.currentOperand || '').toString().replace(/,/g, '');
                const curNum = parseFloat(curClean);
                if (isNaN(curNum)) {
                    return;
                }

                this.showLastExpression = false;
                this.loadedFromHistory = false;
                this.lastExpression = '';

                //Thay đổi phép toán
                if (this.operation != null && this.waitingForNewOperand) {
                    this.operation = operation;
                    this.updateDisplay();
                    return;
                }

                // Thực hiện phép toán trước đó nếu có
                if (this.previousOperand !== '' && !this.waitingForNewOperand) {
                    this.calculate();
                }

                // Set up new operation
                this.justCalculated = false;
                this.operation = operation;
                this.previousOperand = this.currentOperand;
                this.waitingForNewOperand = true;
            }

            calculate() {
                let computation;
                const prev = parseFloat(this.previousOperand);
                const current = parseFloat(this.currentOperand);
                if (isNaN(prev) || isNaN(current)) return;

                let operationSymbol = this.operation;
                switch (this.operation) {
                    case '+':
                        computation = prev + current;
                        break;
                    case '-':
                        computation = prev - current;
                        break;
                    case '×':
                        computation = prev * current;
                        break;
                    case '÷':
                        if (current === 0) {
                            // show error on display
                            this.lastExpression = `${this.previousOperand} ÷ ${this.currentOperand}`;
                            this.showLastExpression = false;
                            this.currentOperand = 'Không thể chia cho 0';
                            this.justCalculated = true;
                            this.updateDisplay();
                            return;
                        }
                        computation = prev / current;
                        break;
                    default:
                        return;
                }

                // Lưu vào lịch sử
                // Prefer the formatted lastExpression (which may include sqr(...) or √(...))
                // when it was set by a unary operation used inside a binary expression.
                let expressionText;
                if (this.showLastExpression && this.lastExpression && this.lastExpression.trim() !== '') {
                    // remove any trailing '=' for history storage
                    expressionText = this.lastExpression.replace(/\s*=$/, '');
                } else {
                    expressionText = `${this.previousOperand} ${operationSymbol} ${this.currentOperand}`;
                }

                const historyItem = {
                    expression: expressionText,
                    result: computation.toString()
                };

                this.history.unshift(historyItem);
                if (this.history.length > 10) {
                    this.history = this.history.slice(0, 10);
                }

                localStorage.setItem('calculatorHistory', JSON.stringify(this.history));
                this.renderHistory();

                this.lastExpression = expressionText;
                this.currentOperand = computation.toString();
                this.operation = undefined;
                this.waitingForNewOperand = true;
                // mark that a full calculation just finished
                this.justCalculated = true;
                this.showLastExpression = false;
            }

            toggleSign() {
                if (this.currentOperand !== '0') {
                    this.currentOperand = (parseFloat(this.currentOperand) * -1).toString();
                }
            }

            calculatePercentage() {
                // Debug: log state to console
                try {
                    console.log('calculatePercentage called', {
                        previousOperand: this.previousOperand,
                        operation: this.operation,
                        currentOperand: this.currentOperand,
                        showLastExpression: this.showLastExpression,
                        loadedFromHistory: this.loadedFromHistory,
                        justCalculated: this.justCalculated
                    });
                } catch (e) { }

                // robust parsing: strip grouping commas before parse
                const curStr = (this.currentOperand || '').toString().replace(/,/g, '');
                const num = parseFloat(curStr);
                if (isNaN(num)) return;

                // If there's a pending binary operation, treat current as percentage of previousOperand
                if (this.previousOperand !== '' && this.operation != null) {
                    const prevStr = (this.previousOperand || '').toString().replace(/,/g, '');
                    const base = parseFloat(prevStr);
                    if (!isNaN(base)) {
                        let percentValue;
                        // For addition/subtraction percent is calculated from base (e.g. base + base*percent)
                        if (this.operation === '+' || this.operation === '-') {
                            percentValue = (base * num / 100);
                        } else {
                            // For multiplication/division treat percent as fraction (e.g. 20% -> 0.2)
                            percentValue = (num / 100);
                        }
                        // show previous as e.g. "200 + 20% =" and current as computed percent (40 or 0.2)
                        this.lastExpression = `${this.previousOperand} ${this.operation} ${num}% =`;
                        this.showLastExpression = true;
                        this.currentOperand = percentValue.toString();
                        this.loadedFromHistory = false;
                        this.updateDisplay();
                        return;
                    }
                }

                // fallback: treat as unary percent
                const result = num / 100;

                // Lưu vào lịch sử
                const historyItem = {
                    expression: `(${this.currentOperand})%`,
                    result: result.toString()
                };

                this.history.unshift(historyItem);
                if (this.history.length > 10) {
                    this.history = this.history.slice(0, 10);
                }
                localStorage.setItem('calculatorHistory', JSON.stringify(this.history));
                this.renderHistory();

                // show percent expression above result
                this.lastExpression = historyItem.expression;
                this.showLastExpression = true;
                this.currentOperand = result.toString();
                this.justCalculated = true;
                this.loadedFromHistory = false;
                this.updateDisplay();
            }

            calculateSquare() {
                // allow squaring any numeric currentOperand (including 0)
                const original = this.currentOperand;
                const num = parseFloat(original);
                if (isNaN(num)) return;
                const result = num * num;

                // If there's a pending binary operation (e.g. previousOperand = 200, operation = '+')
                // then show the full expression like: "200 + sqr(8)" on the previous line and
                // set the current operand to the squared value so the user can press '=' to compute
                // 200 + 64. In this case we do NOT write a history entry yet because the full
                // binary calculation hasn't been completed.
                if (this.previousOperand !== '' && this.operation != null && !this.loadedFromHistory) {
                    this.lastExpression = `${this.previousOperand} ${this.operation} sqr(${original})`;
                    this.showLastExpression = true;
                    this.currentOperand = result.toString();
                    // mark that next number press should start a new operand
                    this.waitingForNewOperand = true;
                    this.justCalculated = false;
                    this.loadedFromHistory = false;
                    this.updateDisplay();
                    return;
                }

                // Fallback: unary square with its own history entry (no pending binary op)
                const historyItem = {
                    expression: `sqr(${original})`,
                    result: result.toString()
                };

                this.history.unshift(historyItem);
                if (this.history.length > 10) {
                    this.history = this.history.slice(0, 10);
                }

                localStorage.setItem('calculatorHistory', JSON.stringify(this.history));
                this.renderHistory();

                this.lastExpression = historyItem.expression;
                this.showLastExpression = true;
                this.currentOperand = result.toString();
                this.justCalculated = true;
                this.loadedFromHistory = false;
                this.updateDisplay();
            }

            calculateSquareRoot() {
                const original = this.currentOperand;
                const num = parseFloat(original);
                if (isNaN(num)) return;
                if (num < 0) {
                    // show error on display
                    this.lastExpression = `√(${original})`;
                    this.showLastExpression = false;
                    this.currentOperand = 'Không thể căn bậc hai số âm';
                    this.justCalculated = true;
                    this.updateDisplay();
                    return;
                }
                const result = Math.sqrt(num);

                // If there's a pending binary operation, show previous + √(current) and
                // set current operand to the sqrt result so '=' will compute the full expression.
                if (this.previousOperand !== '' && this.operation != null && !this.loadedFromHistory) {
                    this.lastExpression = `${this.previousOperand} ${this.operation} √(${original})`;
                    this.showLastExpression = true;
                    this.currentOperand = result.toString();
                    this.waitingForNewOperand = true;
                    this.justCalculated = false;
                    this.loadedFromHistory = false;
                    this.updateDisplay();
                    return;
                }

                // Fallback: unary sqrt with its own history entry
                const historyItem = {
                    expression: `√(${original})`,
                    result: result.toString()
                };

                this.history.unshift(historyItem);
                if (this.history.length > 10) {
                    this.history = this.history.slice(0, 10);
                }

                localStorage.setItem('calculatorHistory', JSON.stringify(this.history));
                this.renderHistory();

                this.lastExpression = historyItem.expression;
                this.showLastExpression = true;
                this.currentOperand = result.toString();
                this.justCalculated = true;
                this.loadedFromHistory = false;
                this.updateDisplay();
            }

            calculateReciprocal() {
                const num = parseFloat(this.currentOperand);
                if (isNaN(num)) return;
                if (num === 0) {
                    // show error on display
                    this.lastExpression = `1/(${this.currentOperand})`;
                    this.showLastExpression = false;
                    this.currentOperand = 'Không thể lấy nghịch đảo 0';
                    this.justCalculated = true;
                    this.updateDisplay();
                    return;
                }
                const result = 1 / num;

                // Lưu vào lịch sử
                const historyItem = {
                    expression: `1/(${this.currentOperand})`,
                    result: result.toString()
                };

                this.history.unshift(historyItem);
                if (this.history.length > 10) {
                    this.history = this.history.slice(0, 10);
                }

                localStorage.setItem('calculatorHistory', JSON.stringify(this.history));
                this.renderHistory();

                this.lastExpression = historyItem.expression;
                this.showLastExpression = true;
                this.currentOperand = result.toString();
                this.justCalculated = true;
                this.loadedFromHistory = false;
                this.updateDisplay();
            }

            clearHistory() {
                this.history = [];
                localStorage.removeItem('calculatorHistory');
                this.renderHistory();
            }

            renderHistory() {
                if (this.history.length === 0) {
                    this.historyContent.innerHTML = '<div class="no-history">Chưa có phép tính nào</div>';
                    return;
                }

                this.historyContent.innerHTML = this.history.map((item, index) => `
                        <div class="history-item" data-index="${index}">
                            <div class="history-expression">${item.expression} =</div>
                            <div class="history-result">${item.result}</div>
                        </div>
                    `).join('');

                // Thêm sự kiện click cho các mục lịch sử
                this.historyContent.querySelectorAll('.history-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        // prevent the click from bubbling to document (which might close the panel)
                        e.stopPropagation();
                        const index = parseInt(item.dataset.index);
                        const historyItem = this.history[index];
                        // load result into current operand without altering the history item's text
                        // Show saved expression on the previous line (e.g. "5 + 3")
                        // include '=' when showing a clicked history expression
                        this.lastExpression = (historyItem.expression ? `${historyItem.expression} =` : '');
                        // clear any stale previousOperand/operation so new operator applies to the shown result
                        this.previousOperand = '';
                        this.operation = undefined;
                        this.showLastExpression = true;
                        // Show saved result as current operand (e.g. "8")
                        this.currentOperand = historyItem.result;
                        this.justCalculated = false;
                        // mark that a history item was loaded; next number press should start new current operand
                        this.loadedFromHistory = true;
                        this.updateDisplay();

                        // on small screens, close the history overlay after selection
                        try {
                            if (window.matchMedia('(max-width: 899px)').matches && typeof closeHistory === 'function') {
                                closeHistory();
                            }
                        } catch (err) {
                            // ignore
                        }
                    });
                });
            }

            getDisplayNumber(number) {
                if (number === '' || number == null) return '';
                // If number is not a numeric value, return it as-is (used for error messages)
                const asNumber = Number(number.toString().replace(/,/g, ''));
                if (isNaN(asNumber)) {
                    return number.toString();
                }
                const stringNumber = number.toString();
                const parts = stringNumber.split('.');
                const integerDigits = parseFloat(parts[0]);
                const decimalDigits = parts[1];
                let integerDisplay;
                if (isNaN(integerDigits)) {
                    integerDisplay = '';
                } else {
                    integerDisplay = integerDigits.toLocaleString('en-US', {
                        maximumFractionDigits: 0
                    });
                }
                if (decimalDigits != null) {
                    return `${integerDisplay}.${decimalDigits}`;
                } else {
                    return integerDisplay;
                }
            }

            updateDisplay() {
                this.currentOperandElement.innerText = this.getDisplayNumber(this.currentOperand);
                // If we should show the full saved expression+result (e.g. after loading history), prefer that
                if (this.showLastExpression && this.lastExpression && this.lastExpression !== '') {
                    this.previousOperandElement.innerText = this.lastExpression;
                    return;
                }

                // Otherwise, if there's an active operation, show previous number plus operator
                if (this.operation != null && this.previousOperand !== '') {
                    this.previousOperandElement.innerText = `${this.getDisplayNumber(this.previousOperand)} ${this.operation}`;
                    return;
                }

                // Fallback: show lastExpression if present
                if (this.lastExpression && this.lastExpression !== '') {
                    // If the last action was a completed calculation, append '=' to indicate result
                    if (this.justCalculated) {
                        this.previousOperandElement.innerText = `${this.lastExpression} =`;
                    } else {
                        this.previousOperandElement.innerText = this.lastExpression;
                    }
                } else {
                    this.previousOperandElement.innerText = '';
                }
            }
        }

        const calculator = new Calculator();

        // Xử lý sự kiện click cho các nút
        const buttons = document.querySelectorAll('.btn');
        console.log('Calculator: buttons found =', buttons.length);
        buttons.forEach(button => {
            console.log('Attaching listener to button', button.innerText || button.dataset.operation || button.dataset.action);
            button.addEventListener('click', (e) => {
                try {
                    if (button.dataset.number) {
                        if (button.dataset.number === '±') {
                            calculator.toggleSign();
                        } else {
                            calculator.appendNumber(button.dataset.number);
                        }
                    } else if (button.dataset.operation) {
                        const op = button.dataset.operation;
                        if (op === 'square') {
                            calculator.calculateSquare();
                        } else if (op === 'sqrt') {
                            calculator.calculateSquareRoot();
                        } else if (op === 'reciprocal') {
                            calculator.calculateReciprocal();
                        } else {
                            calculator.chooseOperation(op);
                        }
                    } else if (button.dataset.action) {
                        if (button.dataset.action === 'calculate') {
                            calculator.calculate();
                        } else if (button.dataset.action === 'clear-entry') {
                            calculator.clearEntry();
                        } else if (button.dataset.action === 'clear-all') {
                            calculator.clear();
                        } else if (button.dataset.action === 'backspace') {
                            calculator.delete();
                        } else if (button.dataset.action === 'percent') {
                            calculator.calculatePercentage();
                        } else if (button.dataset.action === 'toggle-sign') {
                            calculator.toggleSign();
                        }
                    }

                    calculator.updateDisplay();
                } catch (err) {
                    console.error('Calculator button handler error', err);
                    alert('Error: ' + (err && err.message));
                }
            });
        });

        // Xử lý sự kiện bàn phím
        document.addEventListener('keydown', event => {
            if (event.key >= '0' && event.key <= '9') {
                calculator.appendNumber(event.key);
            } else if (event.key === '.' || event.key === ',') {
                // accept both keys but use dot as decimal separator
                calculator.appendNumber('.');
            } else if (event.key === '+' || event.key === '-' || event.key === '*' || event.key === '/') {
                let operation;
                switch (event.key) {
                    case '+': operation = '+'; break;
                    case '-': operation = '-'; break;
                    case '*': operation = '×'; break;
                    case '/': operation = '÷'; break;
                }
                calculator.chooseOperation(operation);
            } else if (event.key === 'Enter' || event.key === '=') {
                calculator.calculate();
            } else if (event.key === 'Escape') {
                calculator.clear();
            } else if (event.key === 'Backspace') {
                calculator.delete();
            }
            calculator.updateDisplay();
        });

        // Xử lý hiển thị/ẩn lịch sử
        const historyToggle = document.getElementById('historyToggle');
        const historyPanel = document.getElementById('historyPanel');
        const clearHistoryBtn = document.getElementById('clearHistory');

        function closeHistory() {
            historyPanel.classList.remove('open');
            historyToggle.classList.remove('active');
        }

        function openHistory() {
            historyPanel.classList.add('open');
            historyToggle.classList.add('active');
        }

        historyToggle.addEventListener('click', (e) => {
            // Prevent the document click handler from immediately closing the panel
            e.stopPropagation();
            e.preventDefault();
            if (historyPanel.classList.contains('open')) {
                closeHistory();
                historyToggle.setAttribute('aria-expanded', 'false');
            } else {
                openHistory();
                historyToggle.setAttribute('aria-expanded', 'true');
            }
        });

        clearHistoryBtn.addEventListener('click', () => {
            calculator.clearHistory();
        });

        // Close history when clicking outside on small screens
        document.addEventListener('click', (e) => {
            if (!window.matchMedia) return;
            if (window.matchMedia('(max-width: 899px)').matches) {
                if (!historyPanel.classList.contains('open')) return;
                // don't close when clicking inside the panel or on the toggle
                const isClickInside = historyPanel.contains(e.target) || historyToggle.contains(e.target);
                if (!isClickInside) closeHistory();
            }
        });

        // Ensure the panel is closed on initial load for small screens
        if (window.matchMedia('(max-width: 899px)').matches) {
            closeHistory();
        }
    </script>
</body>
</html>
