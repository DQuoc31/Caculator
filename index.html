<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Máy tính Windows 11 - Chuẩn</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="Caculator.css">
</head>
<body>
    <div class="calculator-container">
        <div class="calculator">
            <div class="title-bar">
                <button class="menu-btn">
                    <i class="fas fa-bars"></i>
                </button>
                <div class="memory-indicator" id="memoryIndicator" aria-hidden="true" style="margin-right:8px; font-weight:600; color:#0078d7"></div>
                <div class="calculator-type">Chuẩn</div>
                <button class="history-toggle" id="historyToggle">
                    <i class="fas fa-history"></i>
                </button>
            </div>
            
            <div class="display">
                <div class="previous-operand"></div>
                <div class="current-operand">0</div>
            </div>
            
            <!-- Memory row: five buttons across the top -->
            <div class="memory-row">
                <button class="btn btn-clear math-func" data-action="memory-clear">MC</button>
                <button class="btn btn-clear math-func" data-action="memory-recall">MR</button>
                <button class="btn btn-clear math-func" data-action="memory-store">MS</button>
                <button class="btn btn-clear math-func" data-action="memory-add">M+</button>
                <button class="btn btn-clear math-func" data-action="memory-subtract">M-</button>
            </div>

            <div class="buttons-grid">
                <!-- Hàng 1 -->
                <button class="btn btn-clear math-func" data-action="percent">%</button>
                <button class="btn btn-clear" data-action="clear-entry">CE</button>
                <button class="btn btn-clear" data-action="clear-all">C</button>
                <button class="btn btn-clear" data-action="backspace">
                    <i class="fas fa-backspace"></i>
                </button>
                
                <!-- Hàng 2 -->
                <button class="btn btn-operation math-func" data-operation="sqrt">√<span style="text-decoration: overline">x</span></button>
                <button class="btn btn-operation math-func" data-operation="square">x²</button>
                <button class="btn btn-operation math-func" data-operation="reciprocal">¹⁄<span style="text-decoration: overline">x</span></button>
                <button class="btn btn-operation" data-operation="÷">÷</button>
                
                <!-- Hàng 3 -->
                <button class="btn btn-number" data-number="7">7</button>
                <button class="btn btn-number" data-number="8">8</button>
                <button class="btn btn-number" data-number="9">9</button>
                <button class="btn btn-operation" data-operation="×">×</button>
                
                <!-- Hàng 4 -->
                <button class="btn btn-number" data-number="4">4</button>
                <button class="btn btn-number" data-number="5">5</button>
                <button class="btn btn-number" data-number="6">6</button>
                <button class="btn btn-operation" data-operation="-">–</button>
                
                <!-- Hàng 5 -->
                <button class="btn btn-number" data-number="1">1</button>
                <button class="btn btn-number" data-number="2">2</button>
                <button class="btn btn-number" data-number="3">3</button>
                <button class="btn btn-operation" data-operation="+">+</button>
                
                <!-- Hàng 6 -->
                <button class="btn btn-number math-func" data-action="toggle-sign">±</button>
                <button class="btn btn-number" data-number="0">0</button>
                <button class="btn btn-number" data-number=".">.</button>
                <button class="btn btn-equals" data-action="calculate">=</button>
            </div>
        </div>
        
        <div class="history-panel" id="historyPanel">
            <div class="history-header">
                <div style="display:flex;gap:8px;align-items:center;">
                    <button class="tab-btn" id="historyTab" style="font-weight:600;">Lịch sử</button>
                    <button class="tab-btn" id="memoryTab">Bộ nhớ</button>
                </div>
                <button class="clear-history" id="clearPanel">Xóa</button>
            </div>
            <div class="history-content" id="panelContent">
                <div class="no-history">Chưa có mục nào</div>
            </div>
        </div>
    </div>

    <script>
        class Calculator {
            constructor() {
                this.previousOperandElement = document.querySelector('.previous-operand');
                this.currentOperandElement = document.querySelector('.current-operand');
                this.historyContent = null;
                this.history = JSON.parse(localStorage.getItem('calculatorHistory')) || [];
                this.clear();
                this.justCalculated = false; // flag to detect recent calculation
                this.lastExpression = '';
                this.loadedFromHistory = false;
                this.showLastExpression = false;
                this.pendingHistory = null; // store unary result until user confirms with '='
                this.leftUnaryText = '';
                this.leftUnaryActive = false;
                this.memoryValue = parseFloat(localStorage.getItem('calculatorMemory')) || 0;
                this.panelContent = document.getElementById('panelContent');
                if (!this.historyContent) this.historyContent = this.panelContent;
                this.historyTab = document.getElementById('historyTab');
                this.memoryTab = document.getElementById('memoryTab');
                this.clearPanelBtn = document.getElementById('clearPanel');
                // wire tab events
                if (this.historyTab) this.historyTab.addEventListener('click', () => { this.activePanel = 'history'; this.renderPanel(); });
                if (this.memoryTab) this.memoryTab.addEventListener('click', () => { this.activePanel = 'memory'; this.renderPanel(); });
                if (this.clearPanelBtn) this.clearPanelBtn.addEventListener('click', () => { this.clearActivePanel(); });
                this.updateDisplay();
                this.updateMemoryIndicator();
                this.activePanel = 'history'; // 'history' or 'memory'
                this.memoryList = JSON.parse(localStorage.getItem('calculatorMemoryList')) || [];
                this.renderPanel();
            }

            clear() {
                this.currentOperand = '0';
                this.previousOperand = '';
                this.operation = undefined;
                this.waitingForNewOperand = false;
                this.justCalculated = false;
                this.lastExpression = '';
                this.loadedFromHistory = false;
                this.showLastExpression = false;
                this.pendingHistory = null;
                this.leftUnaryText = '';
                this.leftUnaryActive = false;
            }

            clearEntry() {
                this.currentOperand = '0';
                this.justCalculated = false;
            }

            // Memory functions (MC, MR, MS, M+, M-)
            memoryClear() {
                this.memoryValue = 0;
                localStorage.setItem('calculatorMemory', this.memoryValue.toString());
                this.memoryList = [];
                localStorage.removeItem('calculatorMemoryList');
                this.renderPanel();
                this.updateMemoryIndicator();
            }

            memoryRecall() {
                // recall memory into current operand
                this.currentOperand = this.memoryValue.toString();
                this.justCalculated = false;
                this.loadedFromHistory = false;
                this.updateDisplay();
            }

            memoryStore() {
                const num = parseFloat((this.currentOperand || '').toString().replace(/,/g, ''));
                if (isNaN(num)) return;
                this.memoryValue = num;
                localStorage.setItem('calculatorMemory', this.memoryValue.toString());
                this.updateMemoryIndicator();
                // also add to memory list for panel visibility
                this.addMemoryToList('MS', this.memoryValue);
            }

            memoryAdd() {
                let num = parseFloat((this.currentOperand || '').toString().replace(/,/g, ''));
                if (isNaN(num)) {
                    try {
                        const displayed = this.currentOperandElement ? this.currentOperandElement.innerText : '';
                        num = parseFloat((displayed || '').toString().replace(/,/g, ''));
                    } catch (err) {
                        num = NaN;
                    }
                }
                if (isNaN(num)) {
                    console.debug('memoryAdd: cannot parse current operand', this.currentOperand);
                    return;
                }

                const before = parseFloat(this.memoryValue) || 0;
                this.memoryValue = before + num;
                localStorage.setItem('calculatorMemory', this.memoryValue.toString());
                // Add an entry to the memory list so users can see the change in the panel
                this.addMemoryToList('M+', this.memoryValue);
                this.updateMemoryIndicator();
            }

            memorySubtract() {
                let num = parseFloat((this.currentOperand || '').toString().replace(/,/g, ''));
                if (isNaN(num)) {
                    try {
                        const displayed = this.currentOperandElement ? this.currentOperandElement.innerText : '';
                        num = parseFloat((displayed || '').toString().replace(/,/g, ''));
                    } catch (err) {
                        num = NaN;
                    }
                }
                if (isNaN(num)) {
                    console.debug('memorySubtract: cannot parse current operand', this.currentOperand);
                    return;
                }

                const before = parseFloat(this.memoryValue) || 0;
                this.memoryValue = before - num;
                localStorage.setItem('calculatorMemory', this.memoryValue.toString());
                this.addMemoryToList('M-', this.memoryValue);
                this.updateMemoryIndicator();
            }

            updateMemoryIndicator() {
                try {
                    const el = document.getElementById('memoryIndicator');
                    if (!el) return;
                    if (this.memoryValue && !isNaN(this.memoryValue) && this.memoryValue !== 0) {
                        el.innerText = 'M';
                        el.style.opacity = '1';
                    } else {
                        el.innerText = '';
                        el.style.opacity = '0.2';
                    }
                } catch (e) { }
            }

            delete() {
                // If a history item has been loaded into the display, disable backspace until user types or changes state
                if (this.loadedFromHistory) {
                    return;
                }
                // If the last action was a completed calculation, backspace should remove that calculation from history
                if (this.justCalculated) {
                    // clear the result and previous expression
                    this.currentOperand = '0';
                    this.lastExpression = '';
                    this.showLastExpression = false;
                    this.justCalculated = false;
                    return;
                }

                if (this.currentOperand.length === 1) {
                    this.currentOperand = '0';
                } else {
                    this.currentOperand = this.currentOperand.slice(0, -1);
                }
            }

            appendNumber(number = '') {
                // If user just loaded a history item, start a new current operand but keep previousOperand and operation
                if (this.loadedFromHistory) {
                    this.currentOperand = number;
                    this.loadedFromHistory = false;
                    // do not show the saved full expression once user starts typing after operator
                    this.showLastExpression = false;
                    this.waitingForNewOperand = false;
                    this.pendingHistory = null;
                    this.updateDisplay();
                    return;
                }
                // Nếu nhập số sau khi vừa tính toán xong, tạo phép tính mới
                if (this.justCalculated) {
                    // clear previous expression when starting a fresh input
                    this.previousOperand = '';
                    this.lastExpression = '';
                    this.currentOperand = number;
                    this.justCalculated = false;
                    this.waitingForNewOperand = false;
                    return;
                }

                if (this.showLastExpression && this.previousOperand !== '' && this.operation != null) {
                    if (this.leftUnaryActive && this.leftUnaryText && this.lastExpression.startsWith(this.leftUnaryText)) {
                        // start new current operand based on input (handle decimal)
                        if (number === '.') {
                            this.currentOperand = '0.';
                        } else {
                            this.currentOperand = number;
                        }
                        // update the displayed previous expression to include the right-hand operand
                        this.lastExpression = `${this.leftUnaryText} ${this.operation} ${this.currentOperand}`;
                        this.showLastExpression = true;
                        this.loadedFromHistory = false;
                        this.justCalculated = false;
                        this.pendingHistory = null;
                        this.waitingForNewOperand = false;
                        return;
                    }

                    // default behavior: clear preview and start new number
                    this.lastExpression = '';
                    this.showLastExpression = false;
                    this.loadedFromHistory = false;
                    this.justCalculated = false;
                    this.pendingHistory = null;
                    // start new current operand based on input (handle decimal)
                    if (number === '.') {
                        this.currentOperand = '0.';
                    } else {
                        this.currentOperand = number;
                    }
                    this.waitingForNewOperand = false;
                    return;
                }

                if (this.waitingForNewOperand) {
                    this.currentOperand = number;
                    this.waitingForNewOperand = false;
                } else {
                    if (number === '.' && this.currentOperand.includes('.')) return;
                    if (this.currentOperand === '0' && number !== '.') {
                        this.currentOperand = number;
                    } else {
                        this.currentOperand += number;
                    }
                }
            }

            chooseOperation(operation) {
                // If there is no current input, ignore
                if (this.currentOperand === '') return;

                // Prevent choosing an operator when currentOperand is a non-numeric warning/error message
                const curClean = (this.currentOperand || '').toString().replace(/,/g, '');
                const curNum = parseFloat(curClean);
                if (isNaN(curNum)) {
                    return;
                }

                //Thay đổi phép toán
                if (this.operation != null && this.waitingForNewOperand) {
                    if (this.showLastExpression && this.previousOperand !== '' && this.currentOperand !== '') {
                        const prevNum = parseFloat(this.previousOperand);
                        const curNum = parseFloat(this.currentOperand);
                        if (!isNaN(prevNum) && !isNaN(curNum)) {
                            let interim;
                            switch (this.operation) {
                                case '+': interim = prevNum + curNum; break;
                                case '-': interim = prevNum - curNum; break;
                                case '×': interim = prevNum * curNum; break;
                                case '÷':
                                    if (curNum === 0) {
                                        this.lastExpression = `${this.previousOperand} ÷ ${this.currentOperand}`;
                                        this.showLastExpression = false;
                                        this.currentOperand = 'Không thể chia cho 0';
                                        this.justCalculated = true;
                                        this.updateDisplay();
                                        return;
                                    }
                                    interim = prevNum / curNum; break;
                                default:
                                    interim = prevNum;
                            }
                            if (this.lastExpression && this.lastExpression.trim() !== '') {
                                const exprText = this.lastExpression.replace(/\s*=$/, '');
                                const historyItem = { expression: exprText, result: interim.toString() };
                                this.history.unshift(historyItem);
                                if (this.history.length > 10) this.history = this.history.slice(0, 10);
                                localStorage.setItem('calculatorHistory', JSON.stringify(this.history));
                                this.renderHistory();
                            }

                            // Set the computed value as the previous operand and update operator
                            this.previousOperand = interim.toString();
                            this.operation = operation;
                            // clear any unary-preview and pending unary state
                            this.lastExpression = '';
                            this.showLastExpression = false;
                            this.pendingHistory = null;
                            this.leftUnaryText = '';
                            this.leftUnaryActive = false;
                            this.currentOperand = interim.toString();
                            this.waitingForNewOperand = true;
                            this.justCalculated = false;
                            this.loadedFromHistory = false;
                            this.updateDisplay();
                            return;
                        }
                    }

                    // default: just change the pending operator
                    this.operation = operation;
                    this.updateDisplay();
                    return;
                }

                // Thực hiện phép toán trước đó nếu có
                if (this.previousOperand !== '' && !this.waitingForNewOperand) {
                    this.calculate();
                }

                // Clear preview/loaded flags now that we're moving to a new operator flow
                this.showLastExpression = false;
                this.loadedFromHistory = false;
                this.lastExpression = '';

                // Set up new operation
                this.justCalculated = false;
                this.operation = operation;
                if (this.leftUnaryActive && this.leftUnaryText) {
                    this.previousOperand = this.currentOperand; 
                    this.lastExpression = `${this.leftUnaryText} ${operation}`;
                    this.showLastExpression = true;
                } else {
                    this.previousOperand = this.currentOperand;
                }
                this.waitingForNewOperand = true;
            }

            calculate() {
                if (!this.operation && this.pendingHistory) {
                    this.history.unshift(this.pendingHistory);
                    if (this.history.length > 10) this.history = this.history.slice(0, 10);
                    localStorage.setItem('calculatorHistory', JSON.stringify(this.history));
                    this.renderHistory();
                    // clear pending after committing
                    this.pendingHistory = null;
                    // keep lastExpression/currentOperand already set by the unary op
                    this.justCalculated = true;
                    // clear any left-unary tracking because it's now stored
                    this.leftUnaryText = '';
                    this.leftUnaryActive = false;
                    this.updateDisplay();
                    return;
                }

                let computation;
                const prev = parseFloat(this.previousOperand);
                const current = parseFloat(this.currentOperand);
                if (isNaN(prev) || isNaN(current)) return;

                let operationSymbol = this.operation;
                switch (this.operation) {
                    case '+':
                        computation = prev + current;
                        break;
                    case '-':
                        computation = prev - current;
                        break;
                    case '×':
                        computation = prev * current;
                        break;
                    case '÷':
                        if (current === 0) {
                            // show error on display
                            this.lastExpression = `${this.previousOperand} ÷ ${this.currentOperand}`;
                            this.showLastExpression = false;
                            this.currentOperand = 'Không thể chia cho 0';
                            this.justCalculated = true;
                            this.updateDisplay();
                            return;
                        }
                        computation = prev / current;
                        break;
                    default:
                        return;
                }

                // Lưu vào lịch sử
                let expressionText;
                if (this.showLastExpression && this.lastExpression && this.lastExpression.trim() !== '') {
                    // remove any trailing '=' for history storage
                    expressionText = this.lastExpression.replace(/\s*=$/, '');
                } else {
                    expressionText = `${this.previousOperand} ${operationSymbol} ${this.currentOperand}`;
                }

                const historyItem = {
                    expression: expressionText,
                    result: computation.toString()
                };

                this.history.unshift(historyItem);
                if (this.history.length > 10) {
                    this.history = this.history.slice(0, 10);
                }

                localStorage.setItem('calculatorHistory', JSON.stringify(this.history));
                this.renderHistory();

                this.lastExpression = expressionText;
                this.currentOperand = computation.toString();
                this.operation = undefined;
                this.waitingForNewOperand = true;
                // mark that a full calculation just finished
                this.justCalculated = true;
                this.showLastExpression = false;
                // clear left-unary tracking since a full calc finished
                this.leftUnaryText = '';
                this.leftUnaryActive = false;
            }

            toggleSign() {
                if (this.currentOperand !== '0') {
                    this.currentOperand = (parseFloat(this.currentOperand) * -1).toString();
                }
            }

            calculatePercentage() {
                // Debug: log state to console
                try {
                    console.log('calculatePercentage called', {
                        previousOperand: this.previousOperand,
                        operation: this.operation,
                        currentOperand: this.currentOperand,
                        showLastExpression: this.showLastExpression,
                        loadedFromHistory: this.loadedFromHistory,
                        justCalculated: this.justCalculated
                    });
                } catch (e) { }

                // robust parsing: strip grouping commas before parse
                const curStr = (this.currentOperand || '').toString().replace(/,/g, '');
                const num = parseFloat(curStr);
                if (isNaN(num)) return;

                // If there's a pending binary operation, treat current as percentage of previousOperand
                if (this.previousOperand !== '' && this.operation != null) {
                    const prevStr = (this.previousOperand || '').toString().replace(/,/g, '');
                    const base = parseFloat(prevStr);
                    if (!isNaN(base)) {
                        let percentValue;
                        // For addition/subtraction percent is calculated from base (e.g. base + base*percent)
                        if (this.operation === '+' || this.operation === '-') {
                            percentValue = (base * num / 100);
                        } else {
                            // For multiplication/division treat percent as fraction (e.g. 20% -> 0.2)
                            percentValue = (num / 100);
                        }
                        // show previous as e.g. "200 + 20% =" and current as computed percent (40 or 0.2)
                        this.lastExpression = `${this.previousOperand} ${this.operation} ${num}% =`;
                        this.showLastExpression = true;
                        this.currentOperand = percentValue.toString();
                        this.loadedFromHistory = false;
                        this.updateDisplay();
                        return;
                    }
                }

                // fallback: treat as unary percent
                const result = num / 100;

                // Lưu vào lịch sử
                const historyItem = {
                    expression: `(${this.currentOperand})%`,
                    result: result.toString()
                };

                // Store pending unary history; only commit when user presses '='
                this.pendingHistory = historyItem;
                if (this.history.length > 10) {
                    this.history = this.history.slice(0, 10);
                }
                localStorage.setItem('calculatorHistory', JSON.stringify(this.history));
                this.renderHistory();

                // show percent expression above result
                this.lastExpression = historyItem.expression;
                this.showLastExpression = true;
                this.currentOperand = result.toString();
                this.justCalculated = true;
                this.loadedFromHistory = false;
                this.updateDisplay();
            }

            calculateSquare() {
                // allow squaring any numeric currentOperand (including 0)
                const original = this.currentOperand;
                const num = parseFloat(original);
                if (isNaN(num)) return;
                const result = num * num;


                if (this.previousOperand !== '' && this.operation != null && !this.loadedFromHistory) {
                    this.lastExpression = `${this.previousOperand} ${this.operation} sqr(${original})`;
                    this.showLastExpression = true;
                    this.currentOperand = result.toString();
                    // mark that next number press should start a new operand
                    this.waitingForNewOperand = true;
                    this.justCalculated = false;
                    this.loadedFromHistory = false;
                    this.updateDisplay();
                    return;
                }

                let expr;
                if (this.showLastExpression && this.lastExpression && this.lastExpression.trim() !== '') {
                    const inner = this.lastExpression.replace(/\s*=$/, '');
                    expr = `sqr(${inner})`;
                } else {
                    expr = `sqr(${original})`;
                }

                const historyItem = {
                    expression: expr,
                    result: result.toString()
                };

                // Store pending unary history; commit when user presses '='
                this.pendingHistory = historyItem;
                if (this.previousOperand === '' && !this.operation) {
                    this.leftUnaryText = historyItem.expression;
                    this.leftUnaryActive = true;
                }
                if (this.previousOperand === '' && !this.operation) {
                    this.leftUnaryText = historyItem.expression;
                    this.leftUnaryActive = true;
                }
                if (this.history.length > 10) {
                    this.history = this.history.slice(0, 10);
                }

                localStorage.setItem('calculatorHistory', JSON.stringify(this.history));
                this.renderHistory();

                this.lastExpression = historyItem.expression;
                this.showLastExpression = true;
                this.currentOperand = result.toString();
                this.justCalculated = true;
                this.loadedFromHistory = false;
                this.updateDisplay();
            }

            calculateSquareRoot() {
                const original = this.currentOperand;
                const num = parseFloat(original);
                if (isNaN(num)) return;
                if (num < 0) {
                    // show error on display
                    this.lastExpression = `√(${original})`;
                    this.showLastExpression = false;
                    this.currentOperand = 'Không thể căn bậc hai số âm';
                    this.justCalculated = true;
                    this.updateDisplay();
                    return;
                }
                const result = Math.sqrt(num);

                if (this.previousOperand !== '' && this.operation != null && !this.loadedFromHistory) {
                    this.lastExpression = `${this.previousOperand} ${this.operation} √(${original})`;
                    this.showLastExpression = true;
                    this.currentOperand = result.toString();
                    this.waitingForNewOperand = true;
                    this.justCalculated = false;
                    this.loadedFromHistory = false;
                    this.updateDisplay();
                    return;
                }

                let expr;
                if (this.showLastExpression && this.lastExpression && this.lastExpression.trim() !== '') {
                    const inner = this.lastExpression.replace(/\s*=$/, '');
                    expr = `√(${inner})`;
                } else {
                    expr = `√(${original})`;
                }

                const historyItem = {
                    expression: expr,
                    result: result.toString()
                };

                // Store pending unary history; commit when user presses '='
                this.pendingHistory = historyItem;
                if (this.history.length > 10) {
                    this.history = this.history.slice(0, 10);
                }

                localStorage.setItem('calculatorHistory', JSON.stringify(this.history));
                this.renderHistory();

                this.lastExpression = historyItem.expression;
                this.showLastExpression = true;
                this.currentOperand = result.toString();
                this.justCalculated = true;
                this.loadedFromHistory = false;
                this.updateDisplay();
            }

            calculateReciprocal() {
                const num = parseFloat(this.currentOperand);
                if (isNaN(num)) return;
                if (num === 0) {
                    // show error on display
                    this.lastExpression = `1/(${this.currentOperand})`;
                    this.showLastExpression = false;
                    this.currentOperand = 'Không thể lấy nghịch đảo 0';
                    this.justCalculated = true;
                    this.updateDisplay();
                    return;
                }
                const result = 1 / num;

                // Lưu vào lịch sử
                const historyItem = {
                    expression: `1/(${this.currentOperand})`,
                    result: result.toString()
                };

                // Store pending unary history; commit when user presses '='
                this.pendingHistory = historyItem;
                if (this.history.length > 10) {
                    this.history = this.history.slice(0, 10);
                }

                localStorage.setItem('calculatorHistory', JSON.stringify(this.history));
                this.renderHistory();

                this.lastExpression = historyItem.expression;
                this.showLastExpression = true;
                this.currentOperand = result.toString();
                this.justCalculated = true;
                this.loadedFromHistory = false;
                this.updateDisplay();
            }

            clearHistory() {
                this.history = [];
                localStorage.removeItem('calculatorHistory');
                this.renderHistory();
            }

            // Memory list rendering and management (separate from single memoryValue)
            renderMemory() {
                if (!this.panelContent) return;
                if (!this.memoryList || this.memoryList.length === 0) {
                    this.panelContent.innerHTML = '<div class="no-history">Chưa có mục nào</div>';
                    return;
                }
                this.panelContent.innerHTML = this.memoryList.map((item, index) => `
                    <div class="history-item memory-item" data-index="${index}">
                        <div class="history-expression">${item.label || 'Memory'} =</div>
                        <div class="history-result">${item.value}</div>
                    </div>
                `).join('');

                this.panelContent.querySelectorAll('.memory-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const index = parseInt(item.dataset.index);
                        const m = this.memoryList[index];
                        if (!m) return;
                        this.currentOperand = m.value;
                        this.loadedFromHistory = false;
                        this.justCalculated = false;
                        this.updateDisplay();
                    });
                });
            }

            renderPanel() {
                if (!this.panelContent) return;
                if (this.activePanel === 'history') {
                    // render history inside panel
                    if (this.history.length === 0) {
                        this.panelContent.innerHTML = '<div class="no-history">Chưa có phép tính nào</div>';
                    } else {
                        this.panelContent.innerHTML = this.history.map((item, index) => `
                            <div class="history-item" data-index="${index}">
                                <div class="history-expression">${item.expression} =</div>
                                <div class="history-result">${item.result}</div>
                            </div>
                        `).join('');
                        // attach clicks
                        this.panelContent.querySelectorAll('.history-item').forEach(item => {
                            item.addEventListener('click', (e) => {
                                e.stopPropagation();
                                const index = parseInt(item.dataset.index);
                                const historyItem = this.history[index];
                                this.lastExpression = (historyItem.expression ? `${historyItem.expression} =` : '');
                                this.previousOperand = '';
                                this.operation = undefined;
                                this.showLastExpression = true;
                                this.currentOperand = historyItem.result;
                                this.justCalculated = false;
                                this.loadedFromHistory = true;
                                this.pendingHistory = null;
                                this.updateDisplay();
                            });
                        });
                    }
                } else {
                    this.renderMemory();
                }
                // update tab styles
                if (this.historyTab) this.historyTab.style.opacity = this.activePanel === 'history' ? '1' : '0.6';
                if (this.memoryTab) this.memoryTab.style.opacity = this.activePanel === 'memory' ? '1' : '0.6';
            }

            addMemoryToList(label, value) {
                this.memoryList.unshift({ label: label || 'Memory', value: value.toString() });
                if (this.memoryList.length > 20) this.memoryList = this.memoryList.slice(0, 20);
                localStorage.setItem('calculatorMemoryList', JSON.stringify(this.memoryList));
                this.renderPanel();
            }

            clearActivePanel() {
                if (this.activePanel === 'history') {
                    this.clearHistory();
                } else {
                    this.memoryList = [];
                    localStorage.removeItem('calculatorMemoryList');
                    this.renderPanel();
                }
            }

            renderHistory() {
                // Ensure we have a valid DOM container to render history into.
                const target = this.historyContent || this.panelContent;
                if (!target) return; // nothing to render into yet

                if (this.history.length === 0) {
                    target.innerHTML = '<div class="no-history">Chưa có phép tính nào</div>';
                    return;
                }

                target.innerHTML = this.history.map((item, index) => `
                        <div class="history-item" data-index="${index}">
                            <div class="history-expression">${item.expression} =</div>
                            <div class="history-result">${item.result}</div>
                        </div>
                    `).join('');

                // Thêm sự kiện click cho các mục lịch sử
                target.querySelectorAll('.history-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        // prevent the click from bubbling to document (which might close the panel)
                        e.stopPropagation();
                        const index = parseInt(item.dataset.index);
                        const historyItem = this.history[index];
                        this.lastExpression = (historyItem.expression ? `${historyItem.expression} =` : '');
                        // clear any stale previousOperand/operation so new operator applies to the shown result
                        this.previousOperand = '';
                        this.operation = undefined;
                        this.showLastExpression = true;
                        // Show saved result as current operand (e.g. "8")
                        this.currentOperand = historyItem.result;
                        this.justCalculated = false;
                        // mark that a history item was loaded; next number press should start new current operand
                        this.loadedFromHistory = true;
                        this.pendingHistory = null;
                        this.updateDisplay();

                        // on small screens, close the history overlay after selection
                        try {
                            if (window.matchMedia('(max-width: 899px)').matches && typeof closeHistory === 'function') {
                                closeHistory();
                            }
                        } catch (err) {
                            // ignore
                        }
                    });
                });
            }

            getDisplayNumber(number) {
                if (number === '' || number == null) return '';
                // If number is not a numeric value, return it as-is (used for error messages)
                const asNumber = Number(number.toString().replace(/,/g, ''));
                if (isNaN(asNumber)) {
                    return number.toString();
                }
                const stringNumber = number.toString();
                const parts = stringNumber.split('.');
                const integerDigits = parseFloat(parts[0]);
                const decimalDigits = parts[1];
                let integerDisplay;
                if (isNaN(integerDigits)) {
                    integerDisplay = '';
                } else {
                    integerDisplay = integerDigits.toLocaleString('en-US', {
                        maximumFractionDigits: 0
                    });
                }
                if (decimalDigits != null) {
                    return `${integerDisplay}.${decimalDigits}`;
                } else {
                    return integerDisplay;
                }
            }

            updateDisplay() {
                this.currentOperandElement.innerText = this.getDisplayNumber(this.currentOperand);
                // If we should show the full saved expression+result (e.g. after loading history), prefer that
                if (this.showLastExpression && this.lastExpression && this.lastExpression !== '') {
                    this.previousOperandElement.innerText = this.lastExpression;
                    return;
                }

                // Otherwise, if there's an active operation, show previous number plus operator
                if (this.operation != null && this.previousOperand !== '') {
                    this.previousOperandElement.innerText = `${this.getDisplayNumber(this.previousOperand)} ${this.operation}`;
                    return;
                }

                // Fallback: show lastExpression if present
                if (this.lastExpression && this.lastExpression !== '') {
                    // If the last action was a completed calculation, append '=' to indicate result
                    if (this.justCalculated) {
                        this.previousOperandElement.innerText = `${this.lastExpression} =`;
                    } else {
                        this.previousOperandElement.innerText = this.lastExpression;
                    }
                } else {
                    this.previousOperandElement.innerText = '';
                }
            }
        }

        const calculator = new Calculator();

        // Xử lý sự kiện click cho các nút
        const buttons = document.querySelectorAll('.btn');
        console.log('Calculator: buttons found =', buttons.length);
        buttons.forEach(button => {
            console.log('Attaching listener to button', button.innerText || button.dataset.operation || button.dataset.action);
            button.addEventListener('click', (e) => {
                try {
                    if (button.dataset.number) {
                        if (button.dataset.number === '±') {
                            calculator.toggleSign();
                        } else {
                            calculator.appendNumber(button.dataset.number);
                        }
                    } else if (button.dataset.operation) {
                        const op = button.dataset.operation;
                        if (op === 'square') {
                            calculator.calculateSquare();
                        } else if (op === 'sqrt') {
                            calculator.calculateSquareRoot();
                        } else if (op === 'reciprocal') {
                            calculator.calculateReciprocal();
                        } else {
                            calculator.chooseOperation(op);
                        }
                    } else if (button.dataset.action) {
                        if (button.dataset.action === 'calculate') {
                            calculator.calculate();
                        } else if (button.dataset.action === 'clear-entry') {
                            calculator.clearEntry();
                        } else if (button.dataset.action === 'clear-all') {
                            calculator.clear();
                        } else if (button.dataset.action === 'backspace') {
                            calculator.delete();
                        } else if (button.dataset.action === 'percent') {
                            calculator.calculatePercentage();
                        } else if (button.dataset.action === 'memory-clear') {
                            calculator.memoryClear();
                        } else if (button.dataset.action === 'memory-recall') {
                            calculator.memoryRecall();
                        } else if (button.dataset.action === 'memory-store') {
                            calculator.memoryStore();
                        } else if (button.dataset.action === 'memory-add') {
                            calculator.memoryAdd();
                        } else if (button.dataset.action === 'memory-subtract') {
                            calculator.memorySubtract();
                        } else if (button.dataset.action === 'toggle-sign') {
                            calculator.toggleSign();
                        }
                    }

                    calculator.updateDisplay();
                } catch (err) {
                    console.error('Calculator button handler error', err);
                    alert('Error: ' + (err && err.message));
                }
            });
        });

        // Xử lý sự kiện bàn phím
        document.addEventListener('keydown', event => {
            if (event.key >= '0' && event.key <= '9') {
                calculator.appendNumber(event.key);
            } else if (event.key === '.' || event.key === ',') {
                // accept both keys but use dot as decimal separator
                calculator.appendNumber('.');
            } else if (event.key === '+' || event.key === '-' || event.key === '*' || event.key === '/') {
                let operation;
                switch (event.key) {
                    case '+': operation = '+'; break;
                    case '-': operation = '-'; break;
                    case '*': operation = '×'; break;
                    case '/': operation = '÷'; break;
                }
                calculator.chooseOperation(operation);
            } else if (event.key === 'Enter' || event.key === '=') {
                calculator.calculate();
            } else if (event.key === 'Escape') {
                calculator.clear();
            } else if (event.key === 'Backspace') {
                calculator.delete();
            }
            calculator.updateDisplay();
        });

        // Xử lý hiển thị/ẩn lịch sử
    const historyToggle = document.getElementById('historyToggle');
    const historyPanel = document.getElementById('historyPanel');
    // the clear button in the markup is `clearPanel` (not clearHistory)
    const clearHistoryBtn = document.getElementById('clearPanel');

        function closeHistory() {
            if (!historyPanel || !historyToggle) return;
            historyPanel.classList.remove('open');
            historyToggle.classList.remove('active');
        }

        function openHistory() {
            if (!historyPanel || !historyToggle) return;
            historyPanel.classList.add('open');
            historyToggle.classList.add('active');
        }

        if (historyToggle) historyToggle.addEventListener('click', (e) => {
            // Prevent the document click handler from immediately closing the panel
            e.stopPropagation();
            e.preventDefault();
            if (historyPanel.classList.contains('open')) {
                closeHistory();
                historyToggle.setAttribute('aria-expanded', 'false');
            } else {
                openHistory();
                historyToggle.setAttribute('aria-expanded', 'true');
            }
        });

        if (clearHistoryBtn) {
            clearHistoryBtn.addEventListener('click', () => {
                calculator.clearHistory();
            });
        }

        // Close history when clicking outside on small screens
        document.addEventListener('click', (e) => {
            if (!window.matchMedia) return;
            if (window.matchMedia('(max-width: 899px)').matches) {
                if (!historyPanel || !historyPanel.classList.contains('open')) return;
                // don't close when clicking inside the panel or on the toggle
                const isClickInside = historyPanel.contains(e.target) || (historyToggle && historyToggle.contains(e.target));
                if (!isClickInside) closeHistory();
            }
        });

        // Ensure the panel is closed on initial load for small screens
        if (window.matchMedia('(max-width: 899px)').matches) {
            closeHistory();
        }
    </script>
</body>
</html>
